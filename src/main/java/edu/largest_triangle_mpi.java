/**
    This program is the representation of a parallel algorithm which implements
    the Message Passing Interface MPI and is designed to compute the largest
    triangle formed from a set of random points. Each point is represented
    in a planar system with x and y coordinated, and combinations
    of three points are examined to deternime the set with the largest area.

    Course: CSCI 654 - Foundations of Parallel Computing

    @author Kevin Assogba (kta7930)
*/

import mpi.MPI;
import mpi.MPIException;
import java.util.*;

public class largest_triangle_mpi
{
    Point[] points;
    static double max;
    static Point node_a, node_b, node_c;
    static int[] indices;
    static long start;

    /**
    * This main function retrieves the points generated by the random class and
    * launches the computation of the triangles areas.
    *
    * @param args   command line arguments
    *
    */
    public static void main( String[] args ) throws MPIException
    {
        start = System.currentTimeMillis();
        // Read inputs from arguments
        int numPoints = Integer.valueOf(args[0]);
        int side = Integer.valueOf(args[1]);
        int seed = Integer.valueOf(args[2]);

        largest_triangle_mpi lgst_tri_mpi = new largest_triangle_mpi();

        // start computations
        lgst_tri_mpi.get_points(numPoints, side, seed);
        lgst_tri_mpi.run(args, numPoints);

    }

    /**
    * This function implements the MPI framework in order to concurrently
    * compute the largest triangle on available computational resouces.
    *
    * @param args   command line arguments
    * @param numPoints   number of points to examine
    *
    */
    public void run(String[] args, int numPoints) throws MPIException
    {
        // start parallelism
        MPI.Init(args);
        int rank = MPI.COMM_WORLD.getRank(),
            size = MPI.COMM_WORLD.getSize(),
            nint = numPoints / size; // Intervals

        MPI.COMM_WORLD.bcast(numPoints, 1, MPI.INT, 0);
        int[] max_indices = this.get_triangle(numPoints, rank, size);

        // Gather all partial solutions
        int[] all_indices = new int[3 * size];
        MPI.COMM_WORLD.gather(max_indices, 3, MPI.INT, all_indices, 3, MPI.INT, 0);

        if (rank == 0) {this.get_result(all_indices);}
        MPI.COMM_WORLD.barrier();
        MPI.Finalize();
    }

    /**
    * This function creates an instance of random points and iterates through
    * the points in order to store their references in an array.
    *
    * @param numPoints   number of random point to generate
    * @param side   limits of the plane
    * @param seed   seed used to maintain constance in the generation
    *
    */
    public void get_points(int numPoints, int side, int seed)
    {
        // Build a random points set
        RandomPoints rndPoints = new RandomPoints(numPoints, side, seed);
        points = new Point[numPoints];
        int iter = 0;
        Point p;
        while(rndPoints.hasNext()) {
            p = rndPoints.next();
            points[iter++] = p;
        }
    }

    /**
    * This function initiates loops to obtain indices of the points forming
    * a given triangle, computes the area, and check against the max area value
    * to verify if it is the largest.
    *
    * @param numPoints   number of random point to generate
    * @param rank   rank of the running process
    * @param size   size of the available resource pool
    *
    */
    public int[] get_triangle(int numPoints, int rank, int size)
    {
        int[] partial_comb = new int[3]; double partial_area = 0;
        for(int idx_one = rank + 1; idx_one < numPoints - 1; idx_one += size) {

            for (int idx_two = idx_one + 1; idx_two < numPoints; idx_two++) {

                for (int idx_tri = idx_two+1; idx_tri <= numPoints; idx_tri++) {

                    int[] comb = {idx_one, idx_two, idx_tri};

                    triangle abc = process(comb);

                    if (abc.is_largest()) {
                        partial_comb = comb;
                    }
                }
            }
        }
        return partial_comb;
    }

    /**
    * This function retrieves the points corresponding to a combination of
    * indices and generate the corresponding triangle.
    *
    * @param comb   combination of three points forming a triangle
    *
    * @return abc  triangle corresponding to the three points
    *
    */
    public triangle process(int[] comb)
    {
        Point node_one = points[comb[0] - 1];
        Point node_two = points[comb[1] - 1];
        Point node_tri = points[comb[2] - 1];

        triangle abc = new triangle(node_one, node_two, node_tri, comb);
        return abc;
    }

    /**
    * This function receives the data collected from each process by the root,
    * and computes the largest among the local largest of each process in order
    * to obtain the global largest triangle.
    *
    * @param all_data   an array of integers containing the indices of the local
    *                   largest triangles.
    *
    */
    public void get_result(int[] all_data)
    {
        triangle.reset();
        for (int idx = 0; idx < all_data.length && all_data[idx] != 0; idx += 3) {

            int[] comb = {all_data[idx], all_data[idx+1], all_data[idx+2]};

            triangle abc = process(comb);

            if (abc.is_largest()) {
                mark_triangle(abc);
            }
        }
        print_result();
    }

    /**
    * This function marks a triangle as largest if its area is larger than
    * those of already examined triangles. In other words, this function updates
    * the values of the maximum area, the corresponding triangle indices and
    * the coodinates of those points.
    *
    * @param aTriangle   currently the largest triangle found
    *
    */
    public void mark_triangle(triangle aTriangle)
    {
        max = aTriangle.get_area();
        indices = aTriangle.get_indices();
        node_a = aTriangle.a;
        node_b = aTriangle.b;
        node_c = aTriangle.c;
    }

    /**
    * This function is used to print the characteristics
    * of the largest triangle
    *
    */
    public static void print_result()
    {
        System.out.printf ("%d %.5g %.5g%n", indices[0],
                                        node_a.getX(), node_a.getY());
        System.out.printf ("%d %.5g %.5g%n", indices[1],
                                        node_b.getX(), node_b.getY());
        System.out.printf ("%d %.5g %.5g%n", indices[2],
                                        node_c.getX(), node_c.getY());
        System.out.printf("%.5g%n", max);

        float sec = (System.currentTimeMillis() - start) / 1000F;
        System.out.println("largest_triangle_mpi : " + sec + " seconds");
    }

}
